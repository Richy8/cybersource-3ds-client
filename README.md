# CyberSource 3DS Web SDK

A lightweight, framework-agnostic JavaScript SDK for handling CyberSource 3D Secure authentication and Flex Microform card collection in the browser.

## Features

- ‚úÖ **Flex Microform** - PCI-compliant card collection (iFrame-based)
- ‚úÖ **Device Data Collection** - Automated fingerprinting for 3DS 2.x
- ‚úÖ **Challenge UI** - Pre-built modal for 3DS step-up authentication
- ‚úÖ **Smart Loading** - Built-in polling for global Flex dependencies
- ‚úÖ **TypeScript First** - Full type definitions for a better developer experience
- ‚úÖ **Framework Agnostic** - Seamlessly integrates with React, Vue, Angular, or Vanilla JS

---

## üèó High-Level Flow

1.  **Backend Initialization**: Your backend generates a `Capture Context` (a signed JWT) from CyberSource.
2.  **Frontend Rendering**: Use the `WebClient` to render secure iFrame fields into your page.
3.  **Tokenization**: The SDK sends card data directly to CyberSource and returns a `Transient Token`.
4.  **3DS Orchestration**: Collect device data and handle the 3DS Challenge if required by your processor.

---

## Installation

```bash
npm install @deskcreate/cybersource-3ds-web
```

---

## Quick Start

### 1. Include Flex SDK
The Flex Microform script must be included on your page to enable secure card collection.

```html
<script src="https://flex.cybersource.com/cybersource/assets/microform/0.11/flex-microform.min.js"></script>
```

### 2. Initialize the Client

```javascript
import { WebClient } from '@deskcreate/cybersource-3ds-web'

const client = new WebClient()

// üí° Important: Wait for the global Flex script to be ready
await client.waitForLibrary()
```

### 3. Setup Secure Card Input
> [!IMPORTANT]
> **Flex Microform only handles Card Number and CVV.** You MUST collect the Expiry Month and Expiry Year using your own standard HTML inputs.

#### Minimal Setup
```javascript
// 'card-container' is the ID of an empty <div> on your page
const flex = await client.setupFlexMicroform('card-container', captureContext)
```

#### Customized Setup
```javascript
const flex = await client.setupFlexMicroform('card-container', captureContext, {
  layout: 'inline',
  placeholders: {
    cardNumber: '0000 0000 0000 0000',
    securityCode: 'CVV'
  },
  customStyles: {
    fontSize: '15px',
    borderColor: '#e5e7eb',
    borderRadius: '8px'
  }
})
```

### 4. Tokenize & Authenticate
```javascript
// 1. Get the transient token (Pass expiry collected from your own form)
const { token, cardType } = await flex.tokenize(expiryMonth, expiryYear)

// 2. Collect Browser Information (Recommended over iframe-based DDC)
const deviceInfo = await client.collectBrowserInfo()

// 3. Show Challenge Modal (If backend enrollment returns a stepUpUrl)
const result = await client.showChallengeModal(stepUpUrl, accessToken)

if (result.success) {
  await client.closeChallengeModal()
}
```

---

## üìñ Detailed API Reference

### `WebClient`

#### `waitForLibrary(maxRetries?: number, interval?: number)`
- **Mandatory**: Should be called before any Flex-related methods.
- **Default**: 50 retries at 100ms intervals.

#### `setupFlexMicroform(containerId, captureContext, options?)`
- **containerId** (Mandatory): String ID of the mount target.
- **captureContext** (Mandatory): String JWT generated by your backend.
- **options** (Optional): Includes `layout`, `placeholders`, and `customStyles`.

#### `collectBrowserInfo(ipAddress?: string)`
- **Recommended**: Gathers browser fingerprint data (language, timezone, screen resolution, etc.) directly. Use this if you want a frictionless flow without managing extra iframes.
- **ipAddress** (Optional): Provide the client's public IP if already known, otherwise the SDK will attempt to fetch it.

#### `collectDeviceData(deviceDataUrl, accessToken, options?)`
- **Legacy**: Standard CyberSource DDC flow using a hidden iframe.
- **deviceDataUrl** (Mandatory): From CyberSource.
- **accessToken** (Mandatory): From CyberSource.

#### `showChallengeModal(stepUpUrl, accessToken, options?)`
- **stepUpUrl** (Mandatory): From enrollment respond.
- **accessToken** (Mandatory): From enrollment respond.
- **options.transactionId** (Optional): Helps match internal completion events.

---

## üöÄ Realistic Implementation Example

This example demonstrates how the frontend coordinates with your backend API.

```javascript
const handleCheckout = async () => {
  const client = new WebClient()
  await client.waitForLibrary()

  // --- Step 1: Initialize Fields ---
  // Your API should return the Capture Context JWT
  const { captureContext } = await myApi.getCaptureContext()
  const flex = await client.setupFlexMicroform('checkout-ui', captureContext)

  // --- Step 2: Tokenization ---
  // Collect expiry from your own <select> or <input> fields
  const { token, cardType } = await flex.tokenize(myMonth, myYear)

  // --- Step 3: Start 3DS Enrollment ---
  // Collect browser info and send everything to your backend
  const deviceInfo = await client.collectBrowserInfo()

  // CALL YOUR BACKEND API HERE
  const enrollment = await myApi.startPayment({ 
    token, 
    cardType, 
    deviceInfo,
    amount: 100.00 
  })

  // --- Step 4: Handle Challenge ---
  if (enrollment.status === 'PENDING_AUTHENTICATION') {
    const auth = await client.showChallengeModal(
      enrollment.stepUpUrl, 
      enrollment.accessToken,
      { transactionId: enrollment.transactionId }
    )

    if (!auth.success) throw new Error('Authentication Failed')
    await client.closeChallengeModal()
  }

  // --- Step 5: Finalize ---
  // CALL YOUR BACKEND API HERE
  const receipt = await myApi.completePayment(enrollment.transactionId)
  alert('Payment Success: ' + receipt.id)
}
```

## Contributing
See [CONTRIBUTING.md](CONTRIBUTING.md) for details.

## License
MIT License.
